<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`faer` is a general-purpose linear algebra library for rust, with a focus on high performance for algebraic operations on medium/large matrices, as well as matrix decompositions"><title>faer - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-84e720fa.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="faer" data-themes="" data-resource-suffix="" data-rustdoc-version="1.89.0 (29483883e 2025-08-04)" data-channel="1.89.0" data-search-js="search-92309212.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-fd3af306.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../faer/index.html">faer</a><span class="version">0.22.6</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#basic-usage" title="basic usage">basic usage</a><ul><li><a href="#example" title="example">example</a></li></ul></li><li><a href="#matrix-decompositions" title="matrix decompositions">matrix decompositions</a><ul><li><a href="#lltop-decomposition" title="$LL^\top$ decomposition">$LL^\top$ decomposition</a></li><li><a href="#lbltop-decomposition" title="$LBL^\top$ decomposition">$LBL^\top$ decomposition</a></li><li><a href="#lu-decomposition-with-partial-pivoting" title="$LU$ decomposition with partial pivoting">$LU$ decomposition with partial pivoting</a></li><li><a href="#lu-decomposition-with-full-pivoting" title="$LU$ decomposition with full pivoting">$LU$ decomposition with full pivoting</a></li><li><a href="#qr-decomposition" title="$QR$ decomposition">$QR$ decomposition</a></li><li><a href="#qr-decomposition-with-column-pivoting" title="$QR$ decomposition with column pivoting">$QR$ decomposition with column pivoting</a></li><li><a href="#singular-value-decomposition" title="singular value decomposition">singular value decomposition</a></li><li><a href="#eigendecomposition" title="eigendecomposition">eigendecomposition</a></li></ul></li><li><a href="#crate-features" title="crate features">crate features</a></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>faer</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/faer/lib.rs.html#1-1289">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><code>faer</code> is a general-purpose linear algebra library for rust, with a focus on high performance
for algebraic operations on medium/large matrices, as well as matrix decompositions</p>
<p>most of the high-level functionality in this library is provided through associated functions in
its vocabulary types: <a href="mat/type.Mat.html" title="type faer::mat::Mat"><code>Mat</code></a>/<a href="mat/type.MatRef.html" title="type faer::mat::MatRef"><code>MatRef</code></a>/<a href="mat/type.MatMut.html" title="type faer::mat::MatMut"><code>MatMut</code></a></p>
<p><code>faer</code> is recommended for applications that handle medium to large dense matrices, and its
design is not well suited for applications that operate mostly on low dimensional vectors and
matrices such as computer graphics or game development. for such applications, <code>nalgebra</code> and
<code>cgmath</code> may be better suited</p>
<h2 id="basic-usage"><a class="doc-anchor" href="#basic-usage">§</a>basic usage</h2>
<p><a href="mat/type.Mat.html" title="type faer::mat::Mat"><code>Mat</code></a> is a resizable matrix type with dynamic capacity, which can be created using
<a href="mat/generic/struct.Mat.html#method.new" title="associated function faer::mat::generic::Mat::new"><code>Mat::new</code></a> to produce an empty $0\times 0$ matrix, <a href="mat/generic/struct.Mat.html#method.zeros" title="associated function faer::mat::generic::Mat::zeros"><code>Mat::zeros</code></a> to create a rectangular
matrix filled with zeros, <a href="mat/generic/struct.Mat.html#method.identity" title="associated function faer::mat::generic::Mat::identity"><code>Mat::identity</code></a> to create an identity matrix, or <a href="mat/generic/struct.Mat.html#method.from_fn" title="associated function faer::mat::generic::Mat::from_fn"><code>Mat::from_fn</code></a>
for the more general case</p>
<p>Given a <code>&amp;Mat&lt;T&gt;</code> (resp. <code>&amp;mut Mat&lt;T&gt;</code>), a <a href="mat/type.MatRef.html" title="type faer::mat::MatRef"><code>MatRef&lt;'_, T&gt;</code></a> (resp. <a href="mat/type.MatMut.html" title="type faer::mat::MatMut"><code>MatMut&lt;'_, T&gt;</code></a>) can be created by calling <a href="mat/generic/struct.Mat.html#method.as_ref" title="method faer::mat::generic::Mat::as_ref"><code>Mat::as_ref</code></a> (resp. <a href="mat/generic/struct.Mat.html#method.as_mut" title="method faer::mat::generic::Mat::as_mut"><code>Mat::as_mut</code></a>), which allow
for more flexibility than <code>Mat</code> in that they allow slicing (<a href="mat/generic/struct.Mat.html#method.get" title="method faer::mat::generic::Mat::get"><code>MatRef::get</code></a>) and splitting
(<a href="mat/generic/struct.Mat.html#method.split_at" title="method faer::mat::generic::Mat::split_at"><code>MatRef::split_at</code></a>)</p>
<p><code>MatRef</code> and <code>MatMut</code> are lightweight view objects. the former can be copied freely while the
latter has move and reborrow semantics, as described in its documentation</p>
<p>most of the matrix operations can be used through the corresponding math operators: <code>+</code> for
matrix addition, <code>-</code> for subtraction, <code>*</code> for either scalar or matrix multiplication depending
on the types of the operands.</p>
<h3 id="example"><a class="doc-anchor" href="#example">§</a>example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>faer::{Mat, Scale, mat};

<span class="kw">let </span>a = <span class="macro">mat!</span>[
	[<span class="number">1.0</span>, <span class="number">5.0</span>, <span class="number">9.0</span>], <span class="comment">//
	</span>[<span class="number">2.0</span>, <span class="number">6.0</span>, <span class="number">10.0</span>],
	[<span class="number">3.0</span>, <span class="number">7.0</span>, <span class="number">11.0</span>],
	[<span class="number">4.0</span>, <span class="number">8.0</span>, <span class="number">12.0f64</span>],
];

<span class="kw">let </span>b = Mat::from_fn(<span class="number">4</span>, <span class="number">3</span>, |i, j| (i + j) <span class="kw">as </span>f64);

<span class="kw">let </span>add = <span class="kw-2">&amp;</span>a + <span class="kw-2">&amp;</span>b;
<span class="kw">let </span>sub = <span class="kw-2">&amp;</span>a - <span class="kw-2">&amp;</span>b;
<span class="kw">let </span>scale = Scale(<span class="number">3.0</span>) * <span class="kw-2">&amp;</span>a;
<span class="kw">let </span>mul = <span class="kw-2">&amp;</span>a * b.transpose();

<span class="kw">let </span>a00 = a[(<span class="number">0</span>, <span class="number">0</span>)];</code></pre></div>
<h2 id="matrix-decompositions"><a class="doc-anchor" href="#matrix-decompositions">§</a>matrix decompositions</h2>
<p><code>faer</code> provides a variety of matrix factorizations, each with its own advantages and drawbacks:</p>
<h3 id="lltop-decomposition"><a class="doc-anchor" href="#lltop-decomposition">§</a>$LL^\top$ decomposition</h3>
<p><a href="mat/generic/struct.Mat.html#method.llt" title="method faer::mat::generic::Mat::llt"><code>Mat::llt</code></a> decomposes a self-adjoint positive definite matrix $A$ such that
$$A = LL^H,$$
where $L$ is a lower triangular matrix. this decomposition is highly efficient and has good
stability properties</p>
<p><a href="sparse/linalg/solvers/struct.Llt.html" title="struct faer::sparse::linalg::solvers::Llt">an implementation for sparse matrices is also available</a></p>
<h3 id="lbltop-decomposition"><a class="doc-anchor" href="#lbltop-decomposition">§</a>$LBL^\top$ decomposition</h3>
<p><a href="mat/generic/struct.Mat.html#method.lblt" title="method faer::mat::generic::Mat::lblt"><code>Mat::lblt</code></a> decomposes a self-adjoint (possibly indefinite) matrix $A$ such that
$$P A P^\top = LBL^H,$$
where $P$ is a permutation matrix, $L$ is a lower triangular matrix, and $B$ is a block
diagonal matrix, with $1 \times 1$ or $2 \times 2$ diagonal blocks.
this decomposition is efficient and has good stability properties</p>
<h3 id="lu-decomposition-with-partial-pivoting"><a class="doc-anchor" href="#lu-decomposition-with-partial-pivoting">§</a>$LU$ decomposition with partial pivoting</h3>
<p><a href="mat/generic/struct.Mat.html#method.partial_piv_lu" title="method faer::mat::generic::Mat::partial_piv_lu"><code>Mat::partial_piv_lu</code></a> decomposes a square invertible matrix $A$ into a lower triangular
matrix $L$, a unit upper triangular matrix $U$, and a permutation matrix $P$, such that
$$PA = LU$$
it is used by default for computing the determinant, and is generally the recommended method
for solving a square linear system or computing the inverse of a matrix (although we generally
recommend using a <a href="linalg/solvers/trait.Solve.html" title="trait faer::linalg::solvers::Solve"><code>faer::linalg::solvers::Solve</code></a> instead of
computing the inverse explicitly)</p>
<p><a href="sparse/linalg/solvers/struct.Lu.html" title="struct faer::sparse::linalg::solvers::Lu">an implementation for sparse matrices is also available</a></p>
<h3 id="lu-decomposition-with-full-pivoting"><a class="doc-anchor" href="#lu-decomposition-with-full-pivoting">§</a>$LU$ decomposition with full pivoting</h3>
<p><a href="mat/generic/struct.Mat.html#method.full_piv_lu" title="method faer::mat::generic::Mat::full_piv_lu"><code>Mat::full_piv_lu</code></a> decomposes a generic rectangular matrix $A$ into a lower triangular
matrix $L$, a unit upper triangular matrix $U$, and permutation matrices $P$ and $Q$, such that
$$PAQ^\top = LU$$
it can be more stable than the LU decomposition with partial pivoting, in exchange for being
more computationally expensive</p>
<h3 id="qr-decomposition"><a class="doc-anchor" href="#qr-decomposition">§</a>$QR$ decomposition</h3>
<p><a href="mat/generic/struct.Mat.html#method.qr" title="method faer::mat::generic::Mat::qr"><code>Mat::qr</code></a> decomposes a matrix $A$ into the product $$A = QR,$$
where $Q$ is a unitary matrix, and $R$ is an upper trapezoidal matrix. it is often used for
solving least squares problems</p>
<p><a href="sparse/linalg/solvers/struct.Qr.html" title="struct faer::sparse::linalg::solvers::Qr">an implementation for sparse matrices is also available</a></p>
<h3 id="qr-decomposition-with-column-pivoting"><a class="doc-anchor" href="#qr-decomposition-with-column-pivoting">§</a>$QR$ decomposition with column pivoting</h3>
<p>(<a href="mat/generic/struct.Mat.html#method.col_piv_qr" title="method faer::mat::generic::Mat::col_piv_qr"><code>Mat::col_piv_qr</code></a>) decomposes a matrix $A$ into the product $$AP^\top = QR,$$
where $P$ is a permutation matrix, $Q$ is a unitary matrix, and $R$ is an upper trapezoidal
matrix</p>
<p>it is slower than the version with no pivoting, in exchange for being more numerically stable
for rank-deficient matrices</p>
<h3 id="singular-value-decomposition"><a class="doc-anchor" href="#singular-value-decomposition">§</a>singular value decomposition</h3>
<p>the SVD of a matrix $A$ of shape $(m, n)$ is a decomposition into three components $U$, $S$,
and $V$, such that:</p>
<ul>
<li>$U$ has shape $(m, m)$ and is a unitary matrix,</li>
<li>$V$ has shape $(n, n)$ and is a unitary matrix,</li>
<li>$S$ has shape $(m, n)$ and is zero everywhere except the main diagonal, with nonnegative
diagonal values in nonincreasing order,</li>
<li>and finally:</li>
</ul>
<p>$$A = U S V^H$$</p>
<p>the SVD is provided in two forms: either the full matrices $U$ and $V$ are computed, using
<a href="mat/generic/struct.Mat.html#method.svd" title="method faer::mat::generic::Mat::svd"><code>Mat::svd</code></a>, or only their first $\min(m, n)$ columns are computed, using
<a href="mat/generic/struct.Mat.html#method.thin_svd" title="method faer::mat::generic::Mat::thin_svd"><code>Mat::thin_svd</code></a></p>
<p>if only the singular values (elements of $S$) are desired, they can be obtained in
nonincreasing order using <a href="mat/generic/struct.Mat.html#method.singular_values" title="method faer::mat::generic::Mat::singular_values"><code>Mat::singular_values</code></a></p>
<h3 id="eigendecomposition"><a class="doc-anchor" href="#eigendecomposition">§</a>eigendecomposition</h3>
<p><strong>note</strong>: the order of the eigenvalues is currently unspecified and may be changed in a future
release</p>
<p>the eigenvalue decomposition of a square matrix $A$ of shape $(n, n)$ is a decomposition into
two components $U$, $S$:</p>
<ul>
<li>$U$ has shape $(n, n)$ and is invertible,</li>
<li>$S$ has shape $(n, n)$ and is a diagonal matrix,</li>
<li>and finally:</li>
</ul>
<p>$$A = U S U^{-1}$$</p>
<p>if $A$ is self-adjoint, then $U$ can be made unitary ($U^{-1} = U^H$), and $S$ is real valued.
additionally, the eigenvalues are sorted in nondecreasing order</p>
<p>Depending on the domain of the input matrix and whether it is self-adjoint, multiple methods
are provided to compute the eigendecomposition:</p>
<ul>
<li><a href="mat/generic/struct.Mat.html#method.self_adjoint_eigen" title="method faer::mat::generic::Mat::self_adjoint_eigen"><code>Mat::self_adjoint_eigen</code></a> can be used with either real or complex matrices,
producing an eigendecomposition of the same type,</li>
<li><a href="mat/generic/struct.Mat.html#method.eigen" title="method faer::mat::generic::Mat::eigen"><code>Mat::eigen</code></a> can be used with real or complex matrices, but always produces complex values.</li>
</ul>
<p>if only the eigenvalues (elements of $S$) are desired, they can be obtained using
<a href="mat/generic/struct.Mat.html#method.self_adjoint_eigenvalues" title="method faer::mat::generic::Mat::self_adjoint_eigenvalues"><code>Mat::self_adjoint_eigenvalues</code></a> (nondecreasing order), <a href="mat/generic/struct.Mat.html#method.eigenvalues" title="method faer::mat::generic::Mat::eigenvalues"><code>Mat::eigenvalues</code></a>
with the same conditions described above.</p>
<h2 id="crate-features"><a class="doc-anchor" href="#crate-features">§</a>crate features</h2>
<ul>
<li><code>std</code>: enabled by default. links with the standard library to enable additional features such
as cpu feature detection at runtime</li>
<li><code>rayon</code>: enabled by default. enables the <code>rayon</code> parallel backend and enables global
parallelism by default</li>
<li><code>serde</code>: Enables serialization and deserialization of <a href="mat/type.Mat.html" title="type faer::mat::Mat"><code>Mat</code></a></li>
<li><code>npy</code>: enables conversions to/from numpy’s matrix file format</li>
<li><code>perf-warn</code>: produces performance warnings when matrix operations are called with suboptimal
data layout</li>
<li><code>nightly</code>: requires the nightly compiler. enables experimental simd features such as avx512</li>
</ul>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt><code>pub extern crate <a class="mod" href="../dyn_stack/index.html" title="mod dyn_stack">dyn_stack</a>;</code></dt><dt><code>pub extern crate <a class="mod" href="../reborrow/index.html" title="mod reborrow">reborrow</a>;</code></dt><dt><code>pub extern crate <a class="mod" href="../faer_traits/index.html" title="mod faer_traits">faer_traits</a> as traits;</code></dt><dt id="reexport.Col"><code>pub use col::<a class="type" href="col/type.Col.html" title="type faer::col::Col">Col</a>;</code></dt><dt id="reexport.ColMut"><code>pub use col::<a class="type" href="col/type.ColMut.html" title="type faer::col::ColMut">ColMut</a>;</code></dt><dt id="reexport.ColRef"><code>pub use col::<a class="type" href="col/type.ColRef.html" title="type faer::col::ColRef">ColRef</a>;</code></dt><dt id="reexport.Mat"><code>pub use mat::<a class="type" href="mat/type.Mat.html" title="type faer::mat::Mat">Mat</a>;</code></dt><dt id="reexport.MatMut"><code>pub use mat::<a class="type" href="mat/type.MatMut.html" title="type faer::mat::MatMut">MatMut</a>;</code></dt><dt id="reexport.MatRef"><code>pub use mat::<a class="type" href="mat/type.MatRef.html" title="type faer::mat::MatRef">MatRef</a>;</code></dt><dt id="reexport.Row"><code>pub use row::<a class="type" href="row/type.Row.html" title="type faer::row::Row">Row</a>;</code></dt><dt id="reexport.RowMut"><code>pub use row::<a class="type" href="row/type.RowMut.html" title="type faer::row::RowMut">RowMut</a>;</code></dt><dt id="reexport.RowRef"><code>pub use row::<a class="type" href="row/type.RowRef.html" title="type faer::row::RowRef">RowRef</a>;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="col/index.html" title="mod faer::col">col</a></dt><dd>column vector</dd><dt><a class="mod" href="diag/index.html" title="mod faer::diag">diag</a></dt><dd>diagonal matrix</dd><dt><a class="mod" href="io/index.html" title="mod faer::io">io</a></dt><dd>de-serialization from common matrix file formats</dd><dt><a class="mod" href="linalg/index.html" title="mod faer::linalg">linalg</a></dt><dd>linear algebra module</dd><dt><a class="mod" href="mat/index.html" title="mod faer::mat">mat</a></dt><dd>rectangular matrix</dd><dt><a class="mod" href="matrix_free/index.html" title="mod faer::matrix_free">matrix_<wbr>free</a></dt><dd>matrix-free linear operator traits and algorithms</dd><dt><a class="mod" href="perm/index.html" title="mod faer::perm">perm</a></dt><dd>permutation matrix</dd><dt><a class="mod" href="prelude/index.html" title="mod faer::prelude">prelude</a></dt><dd>useful imports for general usage of the library</dd><dt><a class="mod" href="row/index.html" title="mod faer::row">row</a></dt><dd>row vector</dd><dt><a class="mod" href="sparse/index.html" title="mod faer::sparse">sparse</a></dt><dd>sparse matrix data structures</dd><dt><a class="mod" href="stats/index.html" title="mod faer::stats">stats</a></dt><dd>statistics and randomness functionality</dd><dt><a class="mod" href="utils/index.html" title="mod faer::utils">utils</a></dt><dd>helper utilities</dd></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.col.html" title="macro faer::col">col</a></dt><dd>creates a <a href="col/type.Col.html" title="type faer::col::Col"><code>col::Col</code></a> containing the arguments</dd><dt><a class="macro" href="macro.concat.html" title="macro faer::concat">concat</a></dt><dd>concatenates the matrices in each row horizontally,
then concatenates the results vertically</dd><dt><a class="macro" href="macro.make_guard.html" title="macro faer::make_guard">make_<wbr>guard</a></dt><dd>see: <a href="../generativity/macro.make_guard.html" title="macro generativity::make_guard"><code>generativity::make_guard</code></a></dd><dt><a class="macro" href="macro.mat.html" title="macro faer::mat">mat</a></dt><dd>creates a <a href="mat/type.Mat.html" title="type faer::mat::Mat"><code>Mat</code></a> containing the arguments.</dd><dt><a class="macro" href="macro.row.html" title="macro faer::row">row</a></dt><dd>creates a <a href="row/type.Row.html" title="type faer::row::Row"><code>row::Row</code></a> containing the arguments</dd><dt><a class="macro" href="macro.unzip.html" title="macro faer::unzip">unzip</a></dt><dd>used to undo the zipping by the <a href="macro.zip.html" title="macro faer::zip"><code>zip!</code></a> macro.</dd><dt><a class="macro" href="macro.zip.html" title="macro faer::zip">zip</a></dt><dd>zips together matrix of the same size, so that coefficient-wise operations can be performed on
their elements.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.ContiguousBwd.html" title="struct faer::ContiguousBwd">Contiguous<wbr>Bwd</a></dt><dd>contiguous stride equal to <code>-1</code></dd><dt><a class="struct" href="struct.ContiguousFwd.html" title="struct faer::ContiguousFwd">Contiguous<wbr>Fwd</a></dt><dd>contiguous stride equal to <code>+1</code></dd><dt><a class="struct" href="struct.Scale.html" title="struct faer::Scale">Scale</a></dt><dd>scaling factor for multiplying matrices.</dd><dt><a class="struct" href="struct.Spec.html" title="struct faer::Spec">Spec</a></dt><dd>implements <a href="https://doc.rust-lang.org/1.89.0/core/default/trait.Default.html" title="trait core::default::Default"><code>Default</code></a> based on <code>Config</code>’s <a href="trait.Auto.html" title="trait faer::Auto"><code>Auto</code></a> implementation for the type <code>T</code>.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Accum.html" title="enum faer::Accum">Accum</a></dt><dd>determines whether to replace or add to the result of a matmul operatio</dd><dt><a class="enum" href="enum.Conj.html" title="enum faer::Conj">Conj</a></dt><dd>determines whether the input should be implicitly conjugated or not</dd><dt><a class="enum" href="enum.Par.html" title="enum faer::Par">Par</a></dt><dd>determines the parallelization configuration</dd><dt><a class="enum" href="enum.Side.html" title="enum faer::Side">Side</a></dt><dd>determines which side of a self-adjoint matrix should be accessed</dd><dt><a class="enum" href="enum.TryReserveError.html" title="enum faer::TryReserveError">TryReserve<wbr>Error</a></dt><dd>memory allocation error</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Auto.html" title="trait faer::Auto">Auto</a></dt><dd>like <code>Default</code>, but with an extra type parameter so that algorithm hyperparameters can be tuned
per scalar type.</dd><dt><a class="trait" href="trait.Index.html" title="trait faer::Index">Index</a></dt><dd>native unsigned integer type</dd><dt><a class="trait" href="trait.Shape.html" title="trait faer::Shape">Shape</a></dt><dd>matrix dimension</dd><dt><a class="trait" href="trait.ShapeIdx.html" title="trait faer::ShapeIdx">Shape<wbr>Idx</a></dt><dd>base trait for <a href="trait.Shape.html" title="trait faer::Shape"><code>Shape</code></a></dd><dt><a class="trait" href="trait.Stride.html" title="trait faer::Stride">Stride</a></dt><dd>stride distance between two consecutive elements along a given dimension</dd><dt><a class="trait" href="trait.Unbind.html" title="trait faer::Unbind">Unbind</a></dt><dd>sealed trait for types that can be created from “unbound” values, as long as their
struct preconditions are upheld</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.disable_global_parallelism.html" title="fn faer::disable_global_parallelism">disable_<wbr>global_<wbr>parallelism</a></dt><dd>causes functions that access global parallelism settings to panic.</dd><dt><a class="fn" href="fn.get_global_parallelism.html" title="fn faer::get_global_parallelism">get_<wbr>global_<wbr>parallelism</a></dt><dd>gets the global parallelism settings.</dd><dt><a class="fn" href="fn.set_global_parallelism.html" title="fn faer::set_global_parallelism">set_<wbr>global_<wbr>parallelism</a></dt><dd>sets the global parallelism settings.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.Idx.html" title="type faer::Idx">Idx</a></dt><dd>type that can be used to index into a range</dd><dt><a class="type" href="type.IdxInc.html" title="type faer::IdxInc">IdxInc</a></dt><dd>type that can be used to partition a range</dd><dt><a class="type" href="type.MaybeIdx.html" title="type faer::MaybeIdx">Maybe<wbr>Idx</a></dt><dd>either an index or a negative value</dd><dt><a class="type" href="type.c32.html" title="type faer::c32">c32</a></dt><dd><code>Complex&lt;f32&gt;</code></dd><dt><a class="type" href="type.c64.html" title="type faer::c64">c64</a></dt><dd><code>Complex&lt;f64&gt;</code></dd><dt><a class="type" href="type.cx128.html" title="type faer::cx128">cx128</a></dt><dd><code>Complex&lt;f64&gt;</code></dd><dt><a class="type" href="type.fx128.html" title="type faer::fx128">fx128</a></dt><dd><code>Complex&lt;f64&gt;</code></dd></dl></section></div></main></body></html>