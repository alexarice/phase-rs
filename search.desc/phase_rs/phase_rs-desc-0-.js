searchState.loadedDescShard("phase_rs", 0, "The repository contains an implementation of the …\nDefinitions of circuit-normal syntax.\nA syntax of commands and their parsing.\nStructure for representing primitive states in ket …\nNormal-form syntax definitions\nStructure for representing phases, elements of the unit …\nRaw syntax definitions\nHelpers for parsing and pretty printing.\nFunctions and datastructures for type checking\nTyped syntax definitions\nCircuit-normal patterns.\nCircuit-normal terms.\nCircuit-normal terms.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturn a <code>TermT</code> which is the “quotation” of this …\nThe Command structure: a runnable program.\nTypecheck a command, building an <code>Env</code> with gate definitions.\nReturns the argument unchanged.\nList of gates to define, with the name to bind them to.\nCalls <code>U::from(self)</code>.\nFinal term to evaluate.\nHolds a composite ket state of the form ‘|(“0”|“1…\nHolds the value of a ket pattern.\n|-&gt; pattern\n|1&gt; pattern\n|+&gt; pattern\n|0&gt; pattern\nReturns the complement of the state. <code>state</code> and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAn iterator over the individual states for each qubit.\nCreate a new composite ket state from a <code>Vec</code> of <code>KetState</code>\nGet the number of qubits this state needs to be stored.\nCreate a new composite ket state from a single <code>KetState</code>\nReturns the character needed to print this ket state.\nReturns the vector this <code>KetState</code> represents.\nTrait for objects that can built with compositions, …\nBuild an object from an atom.\nBuild a composition object from a sequence of subobjects …\nNormal form patterns\nBuild a tensor product from a sequence of subobjects.\nNormal-form terms.\nA composition “p_1 . … . p_n” with given type\nA single ket state “|x&gt;”\nA normal-form patterns\nA tensor “p_1 x … x p_n”\nAn “atomic” term. Compound terms are evaluated to …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturn a <code>PatternT</code> which is the “quotation” of this …\nSimplifies compositions, tensors, and identities in the …\nConvert a normal-form pattern of type qm &lt; qn to an m x n …\nAn “atomic” term\n“Atomic” terms. Terms which are not compositions or …\nA composition “t_1 ; … ; t_n” with given type\nAn “if let” statement with given pattern, body term, …\nA (global) phase operator, e.g. “-1” or “ph(0.1pi)”\nA tensor “t_1 x … x t_n”\nA normal-form term\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn a <code>TermT</code> which is the “quotation” of this …\nSimplifies compositions, tensors, and identities in the …\nConvert a normal-form term of type qn &lt;-&gt; qn to an n x n …\nConvert a normal-form atom of type qn &lt;-&gt; qn to an n x n …\nSpecifies the phase by an float, which should equal the …\ni phase, equivalent to <code>Angle(0.5)</code>\n-i phase, equivalent to <code>Angle(1.5)</code>\n-1 phase, equivalent to <code>Angle(1.0)</code>\nRepresents a (global) phase operation.\nReturns the angle specified by this phase, divided by pi. …\nReturns the argument unchanged.\nConstruct a new <code>Phase</code> from a float representing the …\nCalls <code>U::from(self)</code>.\nRaw syntax patterns.\nRaw syntax terms.\nA pattern enclosed in parentheses\nA sequence of ket states “|xyz&gt;”, equivalent to “|x&gt; …\nRaw syntax pattern atom with text span. Represents a …\nRaw syntax pattern atom without text span. Represents a …\nRaw syntax tensored pattern with text span. Represents a …\nRaw syntax tensored pattern without text span. Represents …\nRaw syntax pattern with text span. Represents a list of …\nRaw syntax pattern without text span. Represents a list of …\nA unitary pattern\nTypecheck a raw pattern in given environment\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWrapped data\nWrapped data\nWrapped data\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nText span\nText span\nText span\nRaw syntax atom with text span. Represents a term other …\nRaw syntax atom without text span. Represents a term other …\nA term enclosed in parentheses\nTop level symbol, a named gate\nAn identity term “id(n)”\nAn “if let” statement, “if let pattern then inner”\nInverse of a term “t ^ -1”\nA (global) phase operator, e.g. “-1” or “ph(0.1pi)”\nSquare root of a term “sqrt(t)”\nRaw syntax tensored term with text span. Represents a list …\nRaw syntax tensored term without text span. Represents a …\nRaw syntax term with text span. Represents a list of …\nRaw syntax term without text span. Represents a list of …\nTypecheck a raw term in given environment If <code>check_sqrt</code> is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWrapped data\nWrapped data\nWrapped data\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nParser for terms.\nText span\nText span\nText span\nBody of the “if let”\nPattern to match on in “if let”\nTrait for types which can be parsed\nAn identifier\nWraps data of type <code>T</code> in a span of type <code>S</code>, locating it in …\nTrait for types which can be pretty-printed\nTypecheck a raw term in given environment If <code>check_sqrt</code> is …\nTypecheck a raw pattern in given environment\nParse a comment\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWrapped data\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nParse an element of this type.\nText span\nProduce an <code>RcDoc</code> for pretty-printing.\nTyping enviroment, holding definitions of top level …\nError for mismatching type between a term and pattern in …\nError for mismatching type between composed patterns.\nError for when a sqrt operation is applied to a term with …\nErrors that can occur during typechecking.\nError for mismatching type between terms in a composition.\nError for an unknown top-level symbol.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe unknown symbol encountered\nPattern\nPattern 1\nPattern 2\nType of pattern\nSpan of symbol\nSpan of sqrt term causing error\nBody term\nTerm 1\nTerm 2\nTerm which contains compositions\nType of body term\nType of term 1\nType of pattern 1\nType of term 2\nType of pattern 2\nTerm syntax patterns.\nTerm syntax terms.\nA non-empty composition “p_1 . … . p_n”\nA sequence of ket states “|xyz&gt;”, equivalent to “|x&gt; …\nSyntax of typed patterns\nA pattern type “qn &lt; qm”\nA tensor “p_1 x … x p_n”\nA unitary pattern\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the type of this pattern\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert to a raw pattern.\nA non-empty composition “t_1 ; … ; t_n”\nTop level symbol, a named gate\nAn identity “id(n)”\nAn “if let” statement, “if let pattern then inner”\nInverse of a term “t ^ -1”\nA (global) phase operator, e.g. “-1” or “ph(0.1pi)”\nSquare root of a term “sqrt(t)”\nA tensor “t_1 x … x t_n”\nSyntax of typed terms\nA unitary type “qn &lt;-&gt; qn”\nEvaluate a term to a given <code>Buildable</code> type, expanding top …\nReturns a <code>TermC</code> representing the “circuit-normal-form” …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the type of this term\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert a unitary type qn &lt;-&gt; qn to pattern type qn &lt; qn\nConvert to a raw term.\nDefinition of symbol\nBody of the “if let”\nName of symbol/gate\nPattern to match on in “if let”")